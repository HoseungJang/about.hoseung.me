![](/static/catch-fashion-intro.png)

# CATCH FASHION
### 포지션
- 프론트엔드 개발자
- 백엔드 개발자

### 주요 프로덕트
- [CATCH FASHION](https://www.catchfashion.com)
- CATCH FASHION 어드민 웹

### 기술 스택
- 공통
  - Typescript

- Front-end
  - React
  - styled-components

- Back-end
  - AWS
  - Microservice Architecture

- CI/CD
  - Github Actions

---

## 👨🏻‍💻 주요 업무
### 상품 태그 시스템 도입 (2020.09 ~ 2020.10)

![](/static/product-tag.png)

- **설명**
  - 기존의 관련 상품 리스트에서는 같은 카테고리 내의 상품들을 보여주고 있었습니다.

  - 따라서, 조금 더 세밀한 상품 추천을 위해 태그 시스템을 도입했습니다.
    - 예를 들어 "발렌시아가 스피드러너"에 속하는 상품들이 같은 태그를 갖게 하면, 해당 상품들의 페이지에서는 같은 태그에 속한 상품들만 관련 상품 리스트에 나오게 됩니다.

  - 어드민들이 상품과 태그를 관리할 수 있도록 어드민 페이지에 쿼리 빌더 UI를 추가했습니다.
    - 예를 들어, "발렌시아가 스피드러너" 제품군에 속하는 상품들을 태그에 추가 하고 싶으면, 아래와 같은 쿼리를 만들면 됩니다.
    ```
    AND
      (BrandId) is (발렌시아가)
      (CategoryIds) includesOneOf ("여성/신발", "남성/신발")
      (Description) matchesOneOf ("speed", "스피드", "스피드러너")
    ```

- **배운 점 & 어려웠던 점**
  - 컴포넌트를 재사용 가능하며 조립 가능한 형태로 설계하는 것이 많이 어려웠습니다.

    - AND, OR operator는 모든 operator들(includesOneOf, is 등등)을 자식으로 가질 수 있고, 이는 AND, OR 끼리 중첩될 수 있음을 의미했습니다.

    - 즉, AND, OR operator를 기준으로 같은 렌더링 로직을 수행하면 된다는 것을 깨달았고, 컴포넌트를 재귀적으로 호출하는 구조로 해결할 수 있었습니다.

  - 기존의 카테고리 기반 추천 시스템과 새로운 태그 기반 추천 시스템을 비교하는 A/B 테스트를 진행했습니다.

    - 새롭게 도입한 기능이 기존 대비 얼마나 의미있는지 실제 로깅되는 데이터를 통해 비교하는 경험을 해볼 수 있었고, 유저 트래킹의 중요성을 깨달아 제 개인 프로젝트에도 도입해볼 수 있었습니다.

### 새로운 디자인 반영 (2020.08 ~ 2020.09)

![](/static/product-list.png)
![](/static/search-result.png)

- **설명**
  - 상품 리스트 페이지, 검색 결과 페이지에 완전히 새로운 디자인을 적용했습니다.

- **배운 점 & 어려웠던 점**

  - 당시 프론트엔드 개발이 처음이어서 CSS 문법과 React 사용법 등에 익숙하지 못했습니다.
    - 그래서 기본적인 기술들을 빠르게 익히기 위해서 개인 시간을 많이 투자했던 것 같습니다.
    - flex 레이아웃, 미디어 쿼리, React Hooks, Context 등에 익숙해질 수 있었습니다.

  - 필터 구현이 상당히 어려웠습니다. 특정 상황에 필터를 숨기는 작업이나, 필터 하이라이트 작업 등이 필요했는데, 생각보다 많은 예외 상황이 있어서 고전했던 것 같습니다.
    - 그런 복잡한 UI 데이터를 처음 다뤄보면서, "사용자 입장에서 특정 기능이 어떤 상황에 어떻게 동작해야 좋은가?"라는 주제에 대해 많이 생각해볼 수 있었던 것 같습니다.

---

## 🛠 문제 해결

#### Chrome의 Back/Forward Cache 관련 문제
- **설명**
  - 회사 프론트엔드 코드 내에서는 react-query를 사용한 메모리 캐싱을 활용하고, HTTP 단에서는 Cache-Control: no-cache를 설정하여 캐싱을 막고 있었습니다.

  - 그러나, Chrome의 Back/Forward Cache가 맘대로 disk cache를 사용하는 경우가 있었습니다.
    1. 사용자가 뒤로가기를 통해 사이트를 나간다.
    2. 사용자가 앞으로가기를 통해 사이트에 다시 돌아온다.
    3. Back/Forward Cache에 의해 캐싱된 응답을 사용하게 되어서 특정 기능이 sync가 안맞는 문제가 생긴다.

- **원인**
  - no-cache의 경우, 캐싱을 아예 금지하는 것이 아니라, 요청마다 revalidation을 요구하는 방식이었습니다.

  - 즉, Chrome은 캐싱 자체를 완전히 금지하도록 설정된 것이 아니라면 Back/Forward Cache를 진행하도록 구현되었다고 추측했습니다.

- **해결**
  - Cache-Control: no-store로 백엔드의 HTTP Header 설정을 변경하였습니다.

  - no-store는 그 어떤 캐싱도 허용하지 않겠다는 뜻이었고, 이를 통해 문제를 해결할 수 있었습니다.

- **배운점**
  - Cache-Control 헤더와, HTTP 캐싱에 대해 탐구해볼 수 있었습니다.

  - Back/Forward Cache 처럼 브라우저마다 구현이 다른 부분을 더 신경쓰게 되는 계기가 되었습니다.

- **참조**
  - [해당 이슈에 대해 정리한 글](https://velog.io/@alvin/2020.10.29-BackForward-%EC%BA%90%EC%8B%9C-%EB%AC%B8%EC%A0%9C)

#### 네이밍 컨벤션 도입
- **설명**
  - 코드리뷰를 할 때, 네이밍에 관한 이야기가 길어질 때가 자주 있었습니다.

- **원인**
  - 팀 내에 확실하게 정해진 네이밍 컨벤션이 존재하지 않았습니다.
    - 정말 이야기가 필요한 애매한 경우가 아니라, 규칙을 정해놓았다면 빠르게 수정하고 넘어갈 수 있는 문제인 경우가 많았습니다.

  - 암묵적인 규칙, 혹은 적당히 올바른 것 같다는 주관으로 네이밍을 평가하는 것이 아니라, 확실히 근거할 수 있는 규칙을 정해서 문서화하는 것이 좋을 것 같다고 생각했습니다.

- **해결**
  - 네이밍 컨벤션을 도입하자고 의견을 내고, 긴 시간에 걸쳐 팀과 이야기하고 함께 수정하여 초안을 완성할 수 있었습니다.

  - 개발을 하면서 지속적으로 필요한 컨벤션을 추가하고, 애매한 부분을 수정하며 개선하고 있습니다.

- **배운점**
  - 암묵적인 규칙은 주관적인 것이라고 생각하고, 주관은 시간이 흐르며 변할 수 있다고 생각했습니다.
    - 일관된 규칙의 문서화가 일의 효율을 상당히 높일 수 있다는 것을 배웠습니다.

    - "기억보단 기록" 이라는 말을 다시금 되돌아볼 수 있었던 것 같습니다.
